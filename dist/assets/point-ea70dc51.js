const M=Math.PI,y=2*M,u=1e-6,E=y-u;function A(h){this._+=h[0];for(let t=1,s=h.length;t<s;++t)this._+=arguments[t]+h[t]}function T(h){let t=Math.floor(h);if(!(t>=0))throw new Error(`invalid digits: ${h}`);if(t>15)return A;const s=10**t;return function(i){this._+=i[0];for(let n=1,e=i.length;n<e;++n)this._+=Math.round(arguments[n]*s)/s+i[n]}}class L{constructor(t){this._x0=this._y0=this._x1=this._y1=null,this._="",this._append=t==null?A:T(t)}moveTo(t,s){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._append`Z`)}lineTo(t,s){this._append`L${this._x1=+t},${this._y1=+s}`}quadraticCurveTo(t,s,i,n){this._append`Q${+t},${+s},${this._x1=+i},${this._y1=+n}`}bezierCurveTo(t,s,i,n,e,$){this._append`C${+t},${+s},${+i},${+n},${this._x1=+e},${this._y1=+$}`}arcTo(t,s,i,n,e){if(t=+t,s=+s,i=+i,n=+n,e=+e,e<0)throw new Error(`negative radius: ${e}`);let $=this._x1,p=this._y1,r=i-t,o=n-s,a=$-t,l=p-s,_=a*a+l*l;if(this._x1===null)this._append`M${this._x1=t},${this._y1=s}`;else if(_>u)if(!(Math.abs(l*r-o*a)>u)||!e)this._append`L${this._x1=t},${this._y1=s}`;else{let f=i-$,d=n-p,x=r*r+o*o,m=f*f+d*d,g=Math.sqrt(x),v=Math.sqrt(_),w=e*Math.tan((M-Math.acos((x+_-m)/(2*g*v)))/2),c=w/v,b=w/g;Math.abs(c-1)>u&&this._append`L${t+c*a},${s+c*l}`,this._append`A${e},${e},0,0,${+(l*f>a*d)},${this._x1=t+b*r},${this._y1=s+b*o}`}}arc(t,s,i,n,e,$){if(t=+t,s=+s,i=+i,$=!!$,i<0)throw new Error(`negative radius: ${i}`);let p=i*Math.cos(n),r=i*Math.sin(n),o=t+p,a=s+r,l=1^$,_=$?n-e:e-n;this._x1===null?this._append`M${o},${a}`:(Math.abs(this._x1-o)>u||Math.abs(this._y1-a)>u)&&this._append`L${o},${a}`,i&&(_<0&&(_=_%y+y),_>E?this._append`A${i},${i},0,1,${l},${t-p},${s-r}A${i},${i},0,1,${l},${this._x1=o},${this._y1=a}`:_>u&&this._append`A${i},${i},0,${+(_>=M)},${l},${this._x1=t+i*Math.cos(e)},${this._y1=s+i*Math.sin(e)}`)}rect(t,s,i,n){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}h${i=+i}v${+n}h${-i}Z`}toString(){return this._}}function P(h){return function(){return h}}function q(h){let t=3;return h.digits=function(s){if(!arguments.length)return t;if(s==null)t=null;else{const i=Math.floor(s);if(!(i>=0))throw new RangeError(`invalid digits: ${s}`);t=i}return h},()=>new L(t)}var C=Array.prototype.slice;function R(h){return typeof h=="object"&&"length"in h?h:Array.from(h)}function Z(h){return h[0]}function j(h){return h[1]}export{R as a,P as c,C as s,q as w,Z as x,j as y};
